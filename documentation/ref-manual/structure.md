---
tip: translate by openai@2023-06-07 22:29:51
...
---
title: Source Directory Structure
---------------------------------

The `Source Directory`{.interpreted-text role="term"} consists of numerous files, directories and subdirectories; understanding their locations and contents is key to using the Yocto Project effectively. This chapter describes the Source Directory and gives information about those files and directories.

> 源目录包含许多文件、目录和子目录；理解它们的位置和内容对于有效使用 Yocto Project 至关重要。本章描述了源目录，并给出了有关这些文件和目录的信息。

For information on how to establish a local Source Directory on your development system, see the \"`dev-manual/start:locating yocto project source files`{.interpreted-text role="ref"}\" section in the Yocto Project Development Tasks Manual.

> 要了解如何在您的开发系统上建立本地源目录的信息，请参阅 Yocto Project Development Tasks Manual 中的“dev-manual/start：定位 Yocto Project 源文件”部分。

::: note
::: title
Note
:::

The OpenEmbedded build system does not support file or directory names that contain spaces. Be sure that the Source Directory you use does not contain these types of names.

> 开放式嵌入式构建系统不支持包含空格的文件或目录名称。请确保您使用的源目录不包含这些类型的名称。
> :::

# Top-Level Core Components {#structure-core}

This section describes the top-level components of the `Source Directory`{.interpreted-text role="term"}.

## `bitbake/` {#structure-core-bitbake}

This directory includes a copy of BitBake for ease of use. The copy usually matches the current stable BitBake release from the BitBake project. BitBake, a `Metadata`{.interpreted-text role="term"} interpreter, reads the Yocto Project Metadata and runs the tasks defined by that data. Failures are usually caused by errors in your Metadata and not from BitBake itself.

> 这个目录包含一份 BitBake 的副本，以方便使用。该副本通常与 BitBake 项目中的当前稳定版本相匹配。BitBake，一种“元数据”解释器，读取 Yocto 项目元数据并运行由该数据定义的任务。失败通常是由您的元数据中的错误引起的，而不是来自 BitBake 本身。

When you run the `bitbake` command, the main BitBake executable (which resides in the `bitbake/bin/` directory) starts. Sourcing the environment setup script (i.e. `structure-core-script`{.interpreted-text role="ref"}) places the `scripts/` and `bitbake/bin/` directories (in that order) into the shell\'s `PATH` environment variable.

> 当你运行 `bitbake` 命令时，主要的 BitBake 可执行文件（位于 `bitbake/bin/` 目录中）就会启动。源环境设置脚本（即 `structure-core-script`{.interpreted-text role="ref"}）将 `scripts/` 和 `bitbake/bin/` 目录（按顺序）放入 shell 的 `PATH` 环境变量中。

For more information on BitBake, see the `BitBake User Manual <bitbake:index>`{.interpreted-text role="doc"}.

## `build/` {#structure-core-build}

This directory contains user configuration files and the output generated by the OpenEmbedded build system in its standard configuration where the source tree is combined with the output. The `Build Directory`{.interpreted-text role="term"} is created initially when you `source` the OpenEmbedded build environment setup script (i.e. `structure-core-script`{.interpreted-text role="ref"}).

> 这个目录包含用户配置文件以及 OpenEmbedded 构建系统在其标准配置下生成的输出，其中源树与输出结合在一起。当您源自 OpenEmbedded 构建环境设置脚本（即 `structure-core-script`）时，会初始创建 `构建目录`。

It is also possible to place output and configuration files in a directory separate from the `Source Directory`{.interpreted-text role="term"} by providing a directory name when you `source` the setup script. For information on separating output from your local Source Directory files (commonly described as an \"out of tree\" build), see the \"`structure-core-script`{.interpreted-text role="ref"}\" section.

> 也可以在源目录之外提供一个目录名，在源命令的时候把输出和配置文件放到该目录中。有关将输出从本地源目录文件（通常称为“非树状结构”构建）中分离的信息，请参阅“structure-core-script”部分。

See the \"`The Build Directory --- build/ <structure-build>`{.interpreted-text role="ref"}\" section for details about the contents of the `Build Directory`{.interpreted-text role="term"}.

> 查看"构建目录 --- build/<structure-build>"部分，了解有关构建目录内容的详细信息。

## `documentation/` {#handbook}

This directory holds the source for the Yocto Project documentation as well as templates and tools that allow you to generate PDF and HTML versions of the manuals. Each manual is contained in its own sub-folder; for example, the files for this reference manual reside in the `ref-manual/` directory.

> 这个目录包含 Yocto 项目文档的源文件，以及允许您生成手册的 PDF 和 HTML 版本的模板和工具。每个手册都包含在自己的子文件夹中；例如，此参考手册的文件位于 `ref-manual/` 目录中。

## `meta/` {#structure-core-meta}

This directory contains the minimal, underlying OpenEmbedded-Core metadata. The directory holds recipes, common classes, and machine configuration for strictly emulated targets (`qemux86`, `qemuarm`, and so forth.)

> 这个目录包含最小的、基础的 OpenEmbedded-Core 元数据。该目录包含严格模拟目标（如 `qemux86`、`qemuarm` 等）的配方、公共类和机器配置。

## `meta-poky/` {#structure-core-meta-poky}

Designed above the `meta/` content, this directory adds just enough metadata to define the Poky reference distribution.

## `meta-yocto-bsp/` {#structure-core-meta-yocto-bsp}

This directory contains the Yocto Project reference hardware Board Support Packages (BSPs). For more information on BSPs, see the `/bsp-guide/index`{.interpreted-text role="doc"}.

> 这个目录包含 Yocto 项目参考硬件板支持包（BSP）。有关 BSP 的更多信息，请参阅'/bsp-guide/index'。

## `meta-selftest/` {#structure-meta-selftest}

This directory adds additional recipes and append files used by the OpenEmbedded selftests to verify the behavior of the build system. You do not have to add this layer to your `bblayers.conf` file unless you want to run the selftests.

> 这个目录添加了额外的食谱和由 OpenEmbedded selftests 使用的附加文件，以验证构建系统的行为。 除非您想运行 selftests，否则无需将此图层添加到您的 `bblayers.conf` 文件中。

## `meta-skeleton/` {#structure-meta-skeleton}

This directory contains template recipes for BSP and kernel development.

## `scripts/` {#structure-core-scripts}

This directory contains various integration scripts that implement extra functionality in the Yocto Project environment (e.g. QEMU scripts). The `structure-core-script`{.interpreted-text role="ref"} script prepends this directory to the shell\'s `PATH` environment variable.

> 这个目录包含各种集成脚本，它们在 Yocto Project 环境中实现额外功能（例如 QEMU 脚本）。`structure-core-script`{.interpreted-text role="ref"}脚本将此目录添加到 shell 的 `PATH` 环境变量中。

The `scripts` directory has useful scripts that assist in contributing back to the Yocto Project, such as `create-pull-request` and `send-pull-request`.

> `scripts` 目录有有用的脚本，可以帮助向 Yocto Project 贡献，比如 `create-pull-request` 和 `send-pull-request`。

## `oe-init-build-env` {#structure-core-script}

This script sets up the OpenEmbedded build environment. Running this script with the `source` command in a shell makes changes to `PATH` and sets other core BitBake variables based on the current working directory. You need to run an environment setup script before running BitBake commands. The script uses other scripts within the `scripts` directory to do the bulk of the work.

> 此脚本设置 OpenEmbedded 构建环境。使用 shell 中的 `source` 命令运行此脚本可根据当前工作目录更改 `PATH` 并设置其他核心 BitBake 变量。在运行 BitBake 命令之前，需要运行环境设置脚本。该脚本使用 `scripts` 目录中的其他脚本来完成大部分工作。

When you run this script, your Yocto Project environment is set up, a `Build Directory`{.interpreted-text role="term"} is created, your working directory becomes the `Build Directory`{.interpreted-text role="term"}, and you are presented with some simple suggestions as to what to do next, including a list of some possible targets to build. Here is an example:

> 当你运行这个脚本时，你的 Yocto 项目环境就设置好了，会创建一个 `构建目录`，你的工作目录就变成了 `构建目录`，然后会给你一些简单的建议，包括一些可能要构建的目标列表。这里有一个例子：

```
$ source oe-init-build-env

### Shell environment set up for builds. ###

You can now run 'bitbake <target>'

Common targets are:
    core-image-minimal
    core-image-sato
    meta-toolchain
    meta-ide-support

You can also run generated QEMU images with a command like 'runqemu qemux86-64'
```

The default output of the `oe-init-build-env` script is from the `conf-notes.txt` file, which is found in the `meta-poky` directory within the `Source Directory`{.interpreted-text role="term"}. If you design a custom distribution, you can include your own version of this configuration file to mention the targets defined by your distribution. See the \"`dev-manual/custom-template-configuration-directory:creating a custom template configuration directory`{.interpreted-text role="ref"}\" section in the Yocto Project Development Tasks Manual for more information.

> `oe-init-build-env` 脚本的默认输出来自 `Source Directory` 中的 `meta-poky` 目录下的 `conf-notes.txt` 文件。如果你设计一个自定义的发行版，你可以包含自己的这个配置文件来提及你的发行版定义的目标。有关更多信息，请参阅 Yocto Project 开发任务手册中的“`dev-manual/custom-template-configuration-directory:creating a custom template configuration directory`{.interpreted-text role="ref"}”部分。

By default, running this script without a `Build Directory`{.interpreted-text role="term"} argument creates the `build/` directory in your current working directory. If you provide a `Build Directory`{.interpreted-text role="term"} argument when you `source` the script, you direct the OpenEmbedded build system to create a `Build Directory`{.interpreted-text role="term"} of your choice. For example, the following command creates a `Build Directory`{.interpreted-text role="term"} named `mybuilds/` that is outside of the `Source Directory`{.interpreted-text role="term"}:

> 默认情况下，在没有提供 `构建目录` 参数的情况下运行该脚本会在当前工作目录中创建 `build/` 目录。如果在 `源` 脚本时提供 `构建目录` 参数，您可以指定 OpenEmbedded 构建系统创建您选择的 `构建目录`。例如，以下命令会在 `源目录` 之外创建一个名为 `mybuilds/` 的 `构建目录`：

```
$ source oe-init-build-env ~/mybuilds
```

The OpenEmbedded build system uses the template configuration files, which are found by default in the `meta-poky/conf/templates/default` directory in the Source Directory. See the \"`dev-manual/custom-template-configuration-directory:creating a custom template configuration directory`{.interpreted-text role="ref"}\" section in the Yocto Project Development Tasks Manual for more information.

> 开放式嵌入式构建系统使用模板配置文件，这些文件默认位于源目录中的 `meta-poky/conf/templates/default` 目录中。有关更多信息，请参见 Yocto 项目开发任务手册中的“dev-manual/custom-template-configuration-directory：创建自定义模板配置目录”部分。

::: note
::: title
Note
:::

The OpenEmbedded build system does not support file or directory names that contain spaces. If you attempt to run the `oe-init-build-env` script from a Source Directory that contains spaces in either the filenames or directory names, the script returns an error indicating no such file or directory. Be sure to use a Source Directory free of names containing spaces.

> 开放嵌入式构建系统不支持包含空格的文件或目录名称。如果您尝试从包含文件名或目录名中的空格运行 `oe-init-build-env` 脚本，则该脚本将返回指示没有此类文件或目录的错误。请确保使用不包含空格的源目录。
> :::

## `LICENSE, README, and README.hardware` {#structure-basic-top-level}

These files are standard top-level files.

# The Build Directory \-\-- `build/` {#structure-build}

The OpenEmbedded build system creates the `Build Directory`{.interpreted-text role="term"} when you run the build environment setup script `structure-core-script`{.interpreted-text role="ref"}. If you do not give the `Build Directory`{.interpreted-text role="term"} a specific name when you run the setup script, the name defaults to `build/`.

> 系统开放嵌入式编译系统在运行环境设置脚本'structure-core-script'时创建'构建目录'。如果在运行设置脚本时没有给'构建目录'指定特定的名称，默认名称为'build/'。

For subsequent parsing and processing, the name of the Build directory is available via the `TOPDIR`{.interpreted-text role="term"} variable.

## `build/buildhistory/` {#structure-build-buildhistory}

The OpenEmbedded build system creates this directory when you enable build history via the `ref-classes-buildhistory`{.interpreted-text role="ref"} class file. The directory organizes build information into image, packages, and SDK subdirectories. For information on the build history feature, see the \"`dev-manual/build-quality:maintaining build output quality`{.interpreted-text role="ref"}\" section in the Yocto Project Development Tasks Manual.

> 开放嵌入式构建系统可以通过“ref-classes-buildhistory”类文件启用构建历史记录，从而创建此目录。该目录将构建信息组织到镜像、软件包和 SDK 子目录中。有关构建历史记录功能的详细信息，请参阅 Yocto 项目开发任务手册中的“dev-manual/build-quality：维护构建输出质量”部分。

## `build/cache/` {#structure-build-cache}

This directory contains several internal files used by the OpenEmbedded build system.

It also contains `sanity_info`, a text file keeping track of important build information such as the values of `TMPDIR`{.interpreted-text role="term"}, `SSTATE_DIR`{.interpreted-text role="term"}, as well as the name and version of the host distribution.

> 它还包含一个名为 sanity_info 的文本文件，用于跟踪重要的构建信息，比如 `TMPDIR`{.interpreted-text role="term"}、`SSTATE_DIR`{.interpreted-text role="term"}的值，以及主机分发版的名称和版本。

## `build/conf/local.conf` {#structure-build-conf-local.conf}

This configuration file contains all the local user configurations for your build environment. The `local.conf` file contains documentation on the various configuration options. Any variable set here overrides any variable set elsewhere within the environment unless that variable is hard-coded within a file (e.g. by using \'=\' instead of \'?=\'). Some variables are hard-coded for various reasons but such variables are relatively rare.

> 此配置文件包含您构建环境的所有本地用户配置。`local.conf` 文件包含有关各种配置选项的文档。此处设置的任何变量都将覆盖环境中其他位置设置的变量，除非该变量在文件中被硬编码（例如，使用“=”而不是“?=”）。某些变量因各种原因而被硬编码，但这种变量相对较少。

At a minimum, you would normally edit this file to select the target `MACHINE`{.interpreted-text role="term"}, which package types you wish to use (`PACKAGE_CLASSES`{.interpreted-text role="term"}), and the location from which you want to access downloaded files (`DL_DIR`{.interpreted-text role="term"}).

> 至少，您通常会编辑此文件以选择目标 `MACHINE`{.interpreted-text role="term"}，您希望使用的包类型（`PACKAGE_CLASSES`{.interpreted-text role="term"}）以及要访问下载文件的位置（`DL_DIR`{.interpreted-text role="term"}）。

If `local.conf` is not present when you start the build, the OpenEmbedded build system creates it from `local.conf.sample` when you `source` the top-level build environment setup script `structure-core-script`{.interpreted-text role="ref"}.

> 如果在启动构建时未提供 `local.conf`，则当您 `source` 顶级构建环境设置脚本 `structure-core-script` 时，OpenEmbedded 构建系统将从 `local.conf.sample` 中创建它。

The source `local.conf.sample` file used depends on the `TEMPLATECONF`{.interpreted-text role="term"} script variable, which defaults to `meta-poky/conf/templates/default` when you are building from the Yocto Project development environment, and to `meta/conf/templates/default` when you are building from the OpenEmbedded-Core environment. Because the script variable points to the source of the `local.conf.sample` file, this implies that you can configure your build environment from any layer by setting the variable in the top-level build environment setup script as follows:

> `TEMPLATECONF` 脚本变量决定了使用的 `local.conf.sample` 源文件，如果你是从 Yocto 项目开发环境构建，该变量默认为 `meta-poky/conf/templates/default`；如果你是从 OpenEmbedded-Core 环境构建，则为 `meta/conf/templates/default`。由于该变量指向 `local.conf.sample` 文件的源，这意味着你可以通过在顶层构建环境设置脚本中设置该变量来配置你的构建环境：

```
TEMPLATECONF=your_layer/conf/templates/your_template_name
```

Once the build process gets the sample file, it uses `sed` to substitute final `${``OEROOT`{.interpreted-text role="term"}`}` values for all `##OEROOT##` values.

> 一旦构建过程获取了样本文件，就会使用 `sed` 来替换所有 `##OEROOT##` 值的最终 `${OEROOT}` 值。

::: note
::: title
Note
:::

You can see how the `TEMPLATECONF`{.interpreted-text role="term"} variable is used by looking at the `scripts/oe-setup-builddir` script in the `Source Directory`{.interpreted-text role="term"}. You can find the Yocto Project version of the `local.conf.sample` file in the `meta-poky/conf/templates/default` directory.

> 你可以通过查看源目录中的 `scripts/oe-setup-builddir` 脚本来看到 `TEMPLATECONF` 变量是如何使用的。你可以在 `meta-poky/conf/templates/default` 目录中找到 Yocto 项目版本的 `local.conf.sample` 文件。
> :::

## `build/conf/bblayers.conf` {#structure-build-conf-bblayers.conf}

This configuration file defines `layers <dev-manual/layers:understanding and creating layers>`{.interpreted-text role="ref"}, which are directory trees, traversed (or walked) by BitBake. The `bblayers.conf` file uses the `BBLAYERS`{.interpreted-text role="term"} variable to list the layers BitBake tries to find.

> 这个配置文件定义了"层"，它们是 BitBake 遍历的目录树。`bblayers.conf` 文件使用 `BBLAYERS` 变量列出 BitBake 尝试查找的层。

If `bblayers.conf` is not present when you start the build, the OpenEmbedded build system creates it from `bblayers.conf.sample` when you `source` the top-level build environment setup script (i.e. `structure-core-script`{.interpreted-text role="ref"}).

> 如果在构建时不存在 `bblayers.conf`，OpenEmbedded 构建系统会在您 `源` 顶级构建环境设置脚本（即 `structure-core-script`{.interpreted-text role="ref"}）时从 `bblayers.conf.sample` 中创建它。

As with the `local.conf` file, the source `bblayers.conf.sample` file used depends on the `TEMPLATECONF`{.interpreted-text role="term"} script variable, which defaults to `meta-poky/conf/templates/default` when you are building from the Yocto Project development environment, and to `meta/conf/templates/default` when you are building from the OpenEmbedded-Core environment. Because the script variable points to the source of the `bblayers.conf.sample` file, this implies that you can base your build from any layer by setting the variable in the top-level build environment setup script as follows:

> 随着 `local.conf` 文件一样，使用的源 `bblayers.conf.sample` 文件取决于 `TEMPLATECONF` 脚本变量，当从 Yocto 项目开发环境构建时，该变量默认为 `meta-poky/conf/templates/default`，而从 OpenEmbedded-Core 环境构建时，该变量默认为 `meta/conf/templates/default`。由于脚本变量指向 `bblayers.conf.sample` 文件的源，这意味着你可以通过在顶层构建环境设置脚本中设置变量来基于任何层构建：

```
TEMPLATECONF=your_layer/conf/templates/your_template_name
```

Once the build process gets the sample file, it uses `sed` to substitute final `${``OEROOT`{.interpreted-text role="term"}`}` values for all `##OEROOT##` values.

> 一旦构建过程获取了示例文件，它就会使用 `sed` 来替换所有 `##OEROOT##` 值的最终 `${OEROOT}` 值。

::: note
::: title
Note
:::

You can see how the `TEMPLATECONF`{.interpreted-text role="term"} variable is defined by the `scripts/oe-setup-builddir` script in the `Source Directory`{.interpreted-text role="term"}. You can find the Yocto Project version of the `bblayers.conf.sample` file in the `meta-poky/conf/templates/default` directory.

> 你可以在源目录中看到 `TEMPLATECONF` 变量是如何被 `scripts/oe-setup-builddir` 脚本定义的。你可以在 `meta-poky/conf/templates/default` 目录中找到 Yocto 项目版本的 `bblayers.conf.sample` 文件。
> :::

## `build/downloads/` {#structure-build-downloads}

This directory contains downloaded upstream source tarballs. You can reuse the directory for multiple builds or move the directory to another location. You can control the location of this directory through the `DL_DIR`{.interpreted-text role="term"} variable.

> 这个目录包含下载的上游源码压缩包。您可以多次重复使用该目录，或将该目录移至其他位置。您可以通过 `DL_DIR` 变量控制此目录的位置。

## `build/sstate-cache/` {#structure-build-sstate-cache}

This directory contains the shared state cache. You can reuse the directory for multiple builds or move the directory to another location. You can control the location of this directory through the `SSTATE_DIR`{.interpreted-text role="term"} variable.

> 这个目录包含共享状态缓存。您可以将该目录重用于多个构建，或将该目录移动到另一位置。您可以通过 `SSTATE_DIR` 变量控制此目录的位置。

## `build/tmp/` {#structure-build-tmp}

The OpenEmbedded build system creates and uses this directory for all the build system\'s output. The `TMPDIR`{.interpreted-text role="term"} variable points to this directory.

> 系统构建系统 OpenEmbedded 为所有构建系统的输出创建和使用此目录。变量 `TMPDIR`{.interpreted-text role="term"}指向此目录。

BitBake creates this directory if it does not exist. As a last resort, to clean up a build and start it from scratch (other than the downloads), you can remove everything in the `tmp` directory or get rid of the directory completely. If you do, you should also completely remove the `build/sstate-cache` directory.

> BitBake 如果不存在，就会创建这个目录。作为最后的手段，为了清理构建并从头开始（除了下载之外），您可以删除 `tmp` 目录中的所有内容或彻底删除该目录。如果这样做，您还应彻底删除 `build/sstate-cache` 目录。

### `build/tmp/buildstats/` {#structure-build-tmp-buildstats}

This directory stores the build statistics as generated by the `ref-classes-buildstats`{.interpreted-text role="ref"} class.

### `build/tmp/cache/` {#structure-build-tmp-cache}

When BitBake parses the metadata (recipes and configuration files), it caches the results in `build/tmp/cache/` to speed up future builds. The results are stored on a per-machine basis.

> 当 BitBake 解析元数据（配方和配置文件）时，它会将结果缓存在 `build/tmp/cache/` 中以加快未来的构建。这些结果是按机器存储的。

During subsequent builds, BitBake checks each recipe (together with, for example, any files included or appended to it) to see if they have been modified. Changes can be detected, for example, through file modification time (mtime) changes and hashing of file contents. If no changes to the file are detected, then the parsed result stored in the cache is reused. If the file has changed, it is reparsed.

> 在后续构建过程中，BitBake 会检查每个配方（以及例如包含或附加到其中的任何文件），以查看它们是否已被修改。可以通过文件修改时间（mtime）更改和文件内容哈希来检测更改。如果未检测到文件的任何更改，则缓存中存储的解析结果将被重用。如果文件已更改，则将重新解析。

### `build/tmp/deploy/` {#structure-build-tmp-deploy}

This directory contains any \"end result\" output from the OpenEmbedded build process. The `DEPLOY_DIR`{.interpreted-text role="term"} variable points to this directory. For more detail on the contents of the `deploy` directory, see the \"`overview-manual/concepts:images`{.interpreted-text role="ref"}\" and \"`overview-manual/concepts:application development sdk`{.interpreted-text role="ref"}\" sections in the Yocto Project Overview and Concepts Manual.

> 这个目录包含 OpenEmbedded 构建过程中的任何"最终结果"输出。`DEPLOY_DIR`{.interpreted-text role="term"}变量指向此目录。有关 `deploy` 目录内容的更多详细信息，请参阅 Yocto 项目概述和概念手册中的“`overview-manual/concepts:images`{.interpreted-text role="ref"}”和“`overview-manual/concepts:application development sdk`{.interpreted-text role="ref"}”部分。

#### `build/tmp/deploy/deb/` {#structure-build-tmp-deploy-deb}

This directory receives any `.deb` packages produced by the build process. The packages are sorted into feeds for different architecture types.

#### `build/tmp/deploy/rpm/` {#structure-build-tmp-deploy-rpm}

This directory receives any `.rpm` packages produced by the build process. The packages are sorted into feeds for different architecture types.

#### `build/tmp/deploy/ipk/` {#structure-build-tmp-deploy-ipk}

This directory receives `.ipk` packages produced by the build process.

#### `build/tmp/deploy/licenses/` {#structure-build-tmp-deploy-licenses}

This directory receives package licensing information. For example, the directory contains sub-directories for `bash`, `busybox`, and `glibc` (among others) that in turn contain appropriate `COPYING` license files with other licensing information. For information on licensing, see the \"`dev-manual/licenses:maintaining open source license compliance during your product's lifecycle`{.interpreted-text role="ref"}\" section in the Yocto Project Development Tasks Manual.

> 这个目录接收软件许可信息。例如，该目录包含子目录 `bash`、`busybox` 和 `glibc`（等），这些子目录又包含适当的 `COPYING` 许可文件和其他许可信息。有关许可的详细信息，请参阅 Yocto 项目开发任务手册中的“dev-manual/licenses：在您的产品生命周期中维护开源许可合规性”部分。

#### `build/tmp/deploy/images/` {#structure-build-tmp-deploy-images}

This directory is populated with the basic output objects of the build (think of them as the \"generated artifacts\" of the build process), including things like the boot loader image, kernel, root filesystem and more. If you want to flash the resulting image from a build onto a device, look here for the necessary components.

> 这个目录包含编译过程的基本输出对象（将它们视为编译过程的“生成的工件”），包括引导加载程序图像、内核、根文件系统等等。如果要将编译结果的图像刷入设备，请在此处查找必要的组件。

Be careful when deleting files in this directory. You can safely delete old images from this directory (e.g. `core-image-*`). However, the kernel (`*zImage*`, `*uImage*`, etc.), bootloader and other supplementary files might be deployed here prior to building an image. Because these files are not directly produced from the image, if you delete them they will not be automatically re-created when you build the image again.

> 小心删除这个目录中的文件。您可以安全地从这个目录中删除旧图像（例如 `core-image-*`）。但是，在构建图像之前，可能会在这里部署内核（`*zImage*`，`*uImage*` 等），引导程序和其他补充文件。由于这些文件不是直接从图像生成的，如果您删除它们，在您再次构建图像时将不会自动重新创建它们。

If you do accidentally delete files here, you will need to force them to be re-created. In order to do that, you will need to know the target that produced them. For example, these commands rebuild and re-create the kernel files:

> 如果您不小心在这里删除文件，您将需要强制重新创建它们。为此，您需要知道生成它们的目标。例如，以下命令重建并重新创建内核文件：

```
$ bitbake -c clean virtual/kernel
$ bitbake virtual/kernel
```

#### `build/tmp/deploy/sdk/` {#structure-build-tmp-deploy-sdk}

The OpenEmbedded build system creates this directory to hold toolchain installer scripts which, when executed, install the sysroot that matches your target hardware. You can find out more about these installers in the \"`sdk-manual/appendix-obtain:building an sdk installer`{.interpreted-text role="ref"}\" section in the Yocto Project Application Development and the Extensible Software Development Kit (eSDK) manual.

> 开放式嵌入式构建系统创建了这个目录来存放工具链安装程序脚本，当执行时，会安装与目标硬件匹配的 sysroot。您可以在 Yocto 项目应用开发和可扩展软件开发套件（eSDK）手册中的“sdk-manual / appendix-obtain：构建 SDK 安装程序”部分了解更多信息。

### `build/tmp/sstate-control/` {#structure-build-tmp-sstate-control}

The OpenEmbedded build system uses this directory for the shared state manifest files. The shared state code uses these files to record the files installed by each sstate task so that the files can be removed when cleaning the recipe or when a newer version is about to be installed. The build system also uses the manifests to detect and produce a warning when files from one task are overwriting those from another.

> 系统开放的构建系统使用此目录来存储共享状态清单文件。共享状态代码使用这些文件来记录每个 sstate 任务安装的文件，以便在清理配方时或即将安装更新版本时可以删除这些文件。构建系统还使用清单来检测并产生警告，当一个任务的文件覆盖另一个任务的文件时。

### `build/tmp/sysroots-components/` {#structure-build-tmp-sysroots-components}

This directory is the location of the sysroot contents that the task `ref-tasks-prepare_recipe_sysroot`{.interpreted-text role="ref"} links or copies into the recipe-specific sysroot for each recipe listed in `DEPENDS`{.interpreted-text role="term"}. Population of this directory is handled through shared state, while the path is specified by the `COMPONENTS_DIR`{.interpreted-text role="term"} variable. Apart from a few unusual circumstances, handling of the `sysroots-components` directory should be automatic, and recipes should not directly reference `build/tmp/sysroots-components`.

> 这个目录是 `ref-tasks-prepare_recipe_sysroot`{.interpreted-text role="ref"}任务链接或复制到 `DEPENDS`{.interpreted-text role="term"}中列出的每个食谱的食谱特定的 sysroot 的位置。该目录的填充是通过共享状态处理的，而路径由 `COMPONENTS_DIR`{.interpreted-text role="term"}变量指定。除了一些不寻常的情况外，`sysroots-components` 目录的处理应该是自动的，食谱不应直接引用 `build/tmp/sysroots-components`。

### `build/tmp/sysroots/` {#structure-build-tmp-sysroots}

Previous versions of the OpenEmbedded build system used to create a global shared sysroot per machine along with a native sysroot. Since the 2.3 version of the Yocto Project, there are sysroots in recipe-specific `WORKDIR`{.interpreted-text role="term"} directories. Thus, the `build/tmp/sysroots/` directory is unused.

> 以前的 OpenEmbedded 构建系统会在每台机器上创建一个全局共享的系统根目录，以及一个本地系统根目录。自 Yocto Project 2.3 版本以来，系统根目录位于特定配方的 `WORKDIR` 目录中。因此，`build/tmp/sysroots/` 目录不再被使用。

::: note
::: title
Note
:::

The `build/tmp/sysroots/` directory can still be populated using the `bitbake build-sysroots` command and can be used for compatibility in some cases. However, in general it is not recommended to populate this directory. Individual recipe-specific sysroots should be used.

> `build/tmp/sysroots/` 目录仍可使用 `bitbake build-sysroots` 命令填充，并可在某些情况下用于兼容性。但是，一般不建议填充此目录。应使用个别配方特定的 sysroots。
> :::

### `build/tmp/stamps/` {#structure-build-tmp-stamps}

This directory holds information that BitBake uses for accounting purposes to track what tasks have run and when they have run. The directory is sub-divided by architecture, package name, and version. Following is an example:

> 这个目录包含 BitBake 用于记账目的信息，以跟踪哪些任务已经运行，以及何时运行。该目录按照架构、软件包名称和版本进行划分。以下是一个例子：

```
stamps/all-poky-linux/distcc-config/1.0-r0.do_build-2fdd....2do
```

Although the files in the directory are empty of data, BitBake uses the filenames and timestamps for tracking purposes.

For information on how BitBake uses stamp files to determine if a task should be rerun, see the \"`overview-manual/concepts:stamp files and the rerunning of tasks`{.interpreted-text role="ref"}\" section in the Yocto Project Overview and Concepts Manual.

> 要了解 BitBake 如何使用印记文件来确定是否应该重新运行任务，请参阅 Yocto 项目概览和概念手册中的“印记文件和重新运行任务”部分。

### `build/tmp/log/` {#structure-build-tmp-log}

This directory contains general logs that are not otherwise placed using the package\'s `WORKDIR`{.interpreted-text role="term"}. Examples of logs are the output from the `do_check_pkg` or `do_distro_check` tasks. Running a build does not necessarily mean this directory is created.

> 这个目录包含无法使用软件包的 `WORKDIR` 放置的一般日志。日志的示例有 `do_check_pkg` 或 `do_distro_check` 任务的输出。运行构建并不一定意味着会创建这个目录。

### `build/tmp/work/` {#structure-build-tmp-work}

This directory contains architecture-specific work sub-directories for packages built by BitBake. All tasks execute from the appropriate work directory. For example, the source for a particular package is unpacked, patched, configured and compiled all within its own work directory. Within the work directory, organization is based on the package group and version for which the source is being compiled as defined by the `WORKDIR`{.interpreted-text role="term"}.

> 这个目录包含 BitBake 构建的软件包的特定于架构的工作子目录。所有任务都从适当的工作目录执行。例如，特定软件包的源代码在其自己的工作目录中被解压缩，补丁，配置和编译。在工作目录中，组织基于正在编译的软件包组和版本，由 `WORKDIR`{.interpreted-text role="term"}定义。

It is worth considering the structure of a typical work directory. As an example, consider `linux-yocto-kernel-3.0` on the machine `qemux86` built within the Yocto Project. For this package, a work directory of `tmp/work/qemux86-poky-linux/linux-yocto/3.0+git1+<.....>`, referred to as the `WORKDIR`{.interpreted-text role="term"}, is created. Within this directory, the source is unpacked to `linux-qemux86-standard-build` and then patched by Quilt. (See the \"`dev-manual/quilt:using quilt in your workflow`{.interpreted-text role="ref"}\" section in the Yocto Project Development Tasks Manual for more information.) Within the `linux-qemux86-standard-build` directory, standard Quilt directories `linux-3.0/patches` and `linux-3.0/.pc` are created, and standard Quilt commands can be used.

> 考虑一下典型工作目录的结构是值得的。例如，考虑在 Yocto Project 中构建的机器 qemux86 上的 linux-yocto-kernel-3.0。对于此软件包，将创建名为 WORKDIR 的工作目录 tmp/work/qemux86-poky-linux/linux-yocto/3.0+git1+<.....>。在此目录中，源代码将被解压缩到 linux-qemux86-standard-build，然后由 Quilt 进行补丁。（有关更多信息，请参阅 Yocto Project 开发任务手册中的“dev-manual/quilt：在您的工作流程中使用 Quilt”部分。）在 linux-qemux86-standard-build 目录中，将创建标准 Quilt 目录 linux-3.0/patches 和 linux-3.0/.pc，并且可以使用标准 Quilt 命令。

There are other directories generated within `WORKDIR`{.interpreted-text role="term"}. The most important directory is `WORKDIR/temp/`, which has log files for each task (`log.do_*.pid`) and contains the scripts BitBake runs for each task (`run.do_*.pid`). The `WORKDIR/image/` directory is where \"make install\" places its output that is then split into sub-packages within `WORKDIR/packages-split/`.

> 在 `WORKDIR` 中会生成其他目录。最重要的目录是 `WORKDIR/temp/`，它包含每个任务的日志文件（`log.do_*.pid`）和 BitBake 运行每个任务的脚本（`run.do_*.pid`）。`WORKDIR/image/` 目录是“make install”放置其输出的地方，然后在 `WORKDIR/packages-split/` 中拆分为子包。

#### `build/tmp/work/tunearch/recipename/version/` {#structure-build-tmp-work-tunearch-recipename-version}

The recipe work directory \-\-- `${WORKDIR}`.

As described earlier in the \"`structure-build-tmp-sysroots`{.interpreted-text role="ref"}\" section, beginning with the 2.3 release of the Yocto Project, the OpenEmbedded build system builds each recipe in its own work directory (i.e. `WORKDIR`{.interpreted-text role="term"}). The path to the work directory is constructed using the architecture of the given build (e.g. `TUNE_PKGARCH`{.interpreted-text role="term"}, `MACHINE_ARCH`{.interpreted-text role="term"}, or \"allarch\"), the recipe name, and the version of the recipe (i.e. `PE`{.interpreted-text role="term"}`:``PV`{.interpreted-text role="term"}`-``PR`{.interpreted-text role="term"}).

> 按照前面在"结构构建临时系统根"部分的描述，从 Yocto 项目 2.3 版本开始，OpenEmbedded 构建系统会在其自己的工作目录中构建每个配方（即 WORKDIR）。工作目录的路径是根据给定构建的架构（例如 TUNE_PKGARCH，MACHINE_ARCH 或“allarch”），配方名称和配方版本（即 PE：PV-PR）构建的。

Here are key subdirectories within each recipe work directory:

- `${WORKDIR}/temp`: Contains the log files of each task executed for this recipe, the \"run\" files for each executed task, which contain the code run, and a `log.task_order` file, which lists the order in which tasks were executed.

> - `${WORKDIR}/temp`: 包含了本食谱执行的每个任务的日志文件、执行的每个任务的“运行”文件，其中包含运行的代码，以及一个 `log.task_order` 文件，其中列出了任务执行的顺序。

- `${WORKDIR}/image`: Contains the output of the `ref-tasks-install`{.interpreted-text role="ref"} task, which corresponds to the `${``D`{.interpreted-text role="term"}`}` variable in that task.

> `- `${WORKDIR}/image`: 包含`ref-tasks-install`{.interpreted-text role="ref"} 任务的输出，这对应于该任务中的`${``D `{.interpreted-text role="term"}`}` 变量。

- `${WORKDIR}/pseudo`: Contains the pseudo database and log for any tasks executed under pseudo for the recipe.
- `${WORKDIR}/sysroot-destdir`: Contains the output of the `ref-tasks-populate_sysroot`{.interpreted-text role="ref"} task.
- `${WORKDIR}/package`: Contains the output of the `ref-tasks-package`{.interpreted-text role="ref"} task before the output is split into individual packages.

> `${WORKDIR}/package`：在输出被拆分成单独的包之前，存储 `ref-tasks-package`{.interpreted-text role="ref"}任务的输出。

- `${WORKDIR}/packages-split`: Contains the output of the `ref-tasks-package`{.interpreted-text role="ref"} task after the output has been split into individual packages. There are subdirectories for each individual package created by the recipe.

> - `${WORKDIR}/packages-split`: 在将输出分割成单个包之后，包含 `ref-tasks-package`{.interpreted-text role="ref"}任务的输出。 食谱创建了每个单独包的子目录。

- `${WORKDIR}/recipe-sysroot`: A directory populated with the target dependencies of the recipe. This directory looks like the target filesystem and contains libraries that the recipe might need to link against (e.g. the C library).

> `-`${WORKDIR}/recipe-sysroot`：一个填充有配方所需目标依赖项的目录。这个目录看起来像目标文件系统，并包含配方可能需要链接的库（例如 C 库）。

- `${WORKDIR}/recipe-sysroot-native`: A directory populated with the native dependencies of the recipe. This directory contains the tools the recipe needs to build (e.g. the compiler, Autoconf, libtool, and so forth).

> - `${WORKDIR}/recipe-sysroot-native`：一个填充了食谱原生依赖的目录。此目录包含食谱需要构建的工具（例如编译器、Autoconf、libtool 等）。

- `${WORKDIR}/build`: This subdirectory applies only to recipes that support builds where the source is separate from the build artifacts. The OpenEmbedded build system uses this directory as a separate build directory (i.e. `${``B`{.interpreted-text role="term"}`}`).

> - `${WORKDIR}/build`：此子目录仅适用于支持源与构建工件分离的配方。OpenEmbedded 构建系统使用此目录作为单独的构建目录（即 `${B}`）。

### `build/tmp/work-shared/` {#structure-build-work-shared}

For efficiency, the OpenEmbedded build system creates and uses this directory to hold recipes that share a work directory with other recipes. In practice, this is only used for `gcc` and its variants (e.g. `gcc-cross`, `libgcc`, `gcc-runtime`, and so forth).

> 为了提高效率，OpenEmbedded 构建系统创建并使用这个目录来保存与其他配方共享工作目录的配方。实际上，这只用于 gcc 及其变体（例如 gcc-cross、libgcc、gcc-runtime 等）。

# The Metadata \-\-- `meta/` {#structure-meta}

As mentioned previously, `Metadata`{.interpreted-text role="term"} is the core of the Yocto Project. Metadata has several important subdivisions:

## `meta/classes*/` {#structure-meta-classes}

These directories contain the `*.bbclass` files. Class files are used to abstract common code so it can be reused by multiple packages. Every package inherits the `ref-classes-base`{.interpreted-text role="ref"} file. Examples of other important classes are `ref-classes-autotools`{.interpreted-text role="ref"}, which in theory allows any Autotool-enabled package to work with the Yocto Project with minimal effort. Another example is `ref-classes-kernel`{.interpreted-text role="ref"} that contains common code and functions for working with the Linux kernel. Functions like image generation or packaging also have their specific class files such as `ref-classes-image`{.interpreted-text role="ref"}, `ref-classes-rootfs*`{.interpreted-text role="ref"} and `package*.bbclass <ref-classes-package>`{.interpreted-text role="ref"}.

> 这些目录包含 `*.bbclass` 文件。类文件用于抽象常见代码，以便多个软件包可以重用它。每个软件包继承 `ref-classes-base`{.interpreted-text role="ref"}文件。其他重要类的示例有 `ref-classes-autotools`{.interpreted-text role="ref"}，理论上它允许任何 Autotool 启用的软件包在最小的努力下与 Yocto 项目一起工作。另一个示例是 `ref-classes-kernel`{.interpreted-text role="ref"}，其中包含用于处理 Linux 内核的常见代码和函数。像图像生成或打包这样的功能也有特定的类文件，例如 `ref-classes-image`{.interpreted-text role="ref"}、`ref-classes-rootfs*`{.interpreted-text role="ref"}和 `package*.bbclass <ref-classes-package>`{.interpreted-text role="ref"}。

For reference information on classes, see the \"`/ref-manual/classes`{.interpreted-text role="doc"}\" chapter.

## `meta/conf/` {#structure-meta-conf}

This directory contains the core set of configuration files that start from `bitbake.conf` and from which all other configuration files are included. See the include statements at the end of the `bitbake.conf` file and you will note that even `local.conf` is loaded from there. While `bitbake.conf` sets up the defaults, you can often override these by using the (`local.conf`) file, machine file or the distribution configuration file.

> 这个目录包含从 `bitbake.conf` 开始的核心配置文件集，其他所有配置文件都包含在其中。请参见 `bitbake.conf` 文件末尾的 include 语句，您将注意到即使 `local.conf` 也是从那里加载的。虽然 `bitbake.conf` 设置默认值，但您通常可以通过使用（`local.conf`）文件，机器文件或分发配置文件来覆盖这些值。

### `meta/conf/machine/` {#structure-meta-conf-machine}

This directory contains all the machine configuration files. If you set `MACHINE = "qemux86"`, the OpenEmbedded build system looks for a `qemux86.conf` file in this directory. The `include` directory contains various data common to multiple machines. If you want to add support for a new machine to the Yocto Project, look in this directory.

> 这个目录包含所有机器配置文件。如果你将 `MACHINE = "qemux86"` 设置，OpenEmbedded 构建系统会在这个目录中寻找 `qemux86.conf` 文件。`include` 目录包含多台机器共享的各种数据。如果你想为 Yocto 项目添加新机器的支持，请查看这个目录。

### `meta/conf/distro/` {#structure-meta-conf-distro}

The contents of this directory controls any distribution-specific configurations. For the Yocto Project, the `defaultsetup.conf` is the main file here. This directory includes the versions and the `SRCDATE`{.interpreted-text role="term"} definitions for applications that are configured here. An example of an alternative configuration might be `poky-bleeding.conf`. Although this file mainly inherits its configuration from Poky.

> 此目录的内容控制任何特定发行版的配置。对于 Yocto 项目，`defaultsetup.conf` 是此处的主要文件。此目录包括在此处配置的应用程序的版本和 `SRCDATE` 定义。另一种配置的示例可能是 `poky-bleeding.conf`。尽管此文件主要从 Poky 继承其配置。

### `meta/conf/machine-sdk/` {#structure-meta-conf-machine-sdk}

The OpenEmbedded build system searches this directory for configuration files that correspond to the value of `SDKMACHINE`{.interpreted-text role="term"}. By default, 32-bit and 64-bit x86 files ship with the Yocto Project that support some SDK hosts. However, it is possible to extend that support to other SDK hosts by adding additional configuration files in this subdirectory within another layer.

> 系统 OpenEmbedded 构建系统会在此目录中搜索与 `SDKMACHINE` 值对应的配置文件。默认情况下，Yocto Project 提供了支持一些 SDK 主机的 32 位和 64 位 x86 文件。然而，可以通过在另一个层中的此子目录中添加其他配置文件来扩展对其他 SDK 主机的支持。

## `meta/files/` {#structure-meta-files}

This directory contains common license files and several text files used by the build system. The text files contain minimal device information and lists of files and directories with known permissions.

> 这个目录包含常见的许可文件和构建系统使用的几个文本文件。文本文件包含最小的设备信息和具有已知权限的文件和目录的列表。

## `meta/lib/` {#structure-meta-lib}

This directory contains OpenEmbedded Python library code used during the build process. It is enabled via the `addpylib` directive in `meta/conf/local.conf`. For more information, see `bitbake-user-manual/bitbake-user-manual-metadata:extending python library code`{.interpreted-text role="ref"}.

> 此目录包含在构建过程中使用的 OpenEmbedded Python 库代码。它可以通过 `meta/conf/local.conf` 中的 `addpylib` 指令启用。有关更多信息，请参见 `bitbake-user-manual/bitbake-user-manual-metadata：扩展python库代码`{.interpreted-text role="ref"}。

## `meta/recipes-bsp/` {#structure-meta-recipes-bsp}

This directory contains anything linking to specific hardware or hardware configuration information such as \"u-boot\" and \"grub\".

## `meta/recipes-connectivity/` {#structure-meta-recipes-connectivity}

This directory contains libraries and applications related to communication with other devices.

## `meta/recipes-core/` {#structure-meta-recipes-core}

This directory contains what is needed to build a basic working Linux image including commonly used dependencies.

## `meta/recipes-devtools/` {#structure-meta-recipes-devtools}

This directory contains tools that are primarily used by the build system. The tools, however, can also be used on targets.

## `meta/recipes-extended/` {#structure-meta-recipes-extended}

This directory contains non-essential applications that add features compared to the alternatives in core. You might need this directory for full tool functionality.

> 这个目录包含比核心中的替代选项具有更多功能的非必要应用程序。您可能需要这个目录来实现完整的工具功能。

## `meta/recipes-gnome/` {#structure-meta-recipes-gnome}

This directory contains all things related to the GTK+ application framework.

## `meta/recipes-graphics/` {#structure-meta-recipes-graphics}

This directory contains X and other graphically related system libraries.

## `meta/recipes-kernel/` {#structure-meta-recipes-kernel}

This directory contains the kernel and generic applications and libraries that have strong kernel dependencies.

## `meta/recipes-multimedia/` {#structure-meta-recipes-multimedia}

This directory contains codecs and support utilities for audio, images and video.

## `meta/recipes-rt/` {#structure-meta-recipes-rt}

This directory contains package and image recipes for using and testing the `PREEMPT_RT` kernel.

## `meta/recipes-sato/` {#structure-meta-recipes-sato}

This directory contains the Sato demo/reference UI/UX and its associated applications and configuration data.

## `meta/recipes-support/` {#structure-meta-recipes-support}

This directory contains recipes used by other recipes, but that are not directly included in images (i.e. dependencies of other recipes).

## `meta/site/` {#structure-meta-site}

This directory contains a list of cached results for various architectures. Because certain \"autoconf\" test results cannot be determined when cross-compiling due to the tests not able to run on a live system, the information in this directory is passed to \"autoconf\" for the various architectures.

> 这个目录包含了各种架构的缓存结果列表。由于某些“自动配置”测试结果无法在跨编译时确定，因为测试无法在实际系统上运行，所以这个目录中的信息会传递给各种架构的“自动配置”。

## `meta/recipes.txt` {#structure-meta-recipes-txt}

This file is a description of the contents of `recipes-*`.
