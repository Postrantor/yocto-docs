---
tip: translate by openai@2023-06-10 12:07:48
...
---
title: Creating a Read-Only Root Filesystem
-------------------------------------------

Suppose, for security reasons, you need to disable your target device\'s root filesystem\'s write permissions (i.e. you need a read-only root filesystem). Or, perhaps you are running the device\'s operating system from a read-only storage device. For either case, you can customize your image for that behavior.

> 假设出于安全原因，您需要禁用目标设备的根文件系统的写入权限（即您需要一个只读的根文件系统）。或者，也许您正在从只读存储设备运行设备的操作系统。无论哪种情况，您都可以为该行为自定义您的映像。

::: note
::: title
Note
:::

Supporting a read-only root filesystem requires that the system and applications do not try to write to the root filesystem. You must configure all parts of the target system to write elsewhere, or to gracefully fail in the event of attempting to write to the root filesystem.

> 支持只读根文件系统需要系统和应用程序不尝试写入根文件系统。您必须配置目标系统的所有部分，以将写入其他位置，或在尝试写入根文件系统时优雅地失败。
> :::

# Creating the Root Filesystem

To create the read-only root filesystem, simply add the \"read-only-rootfs\" feature to your image, normally in one of two ways. The first way is to add the \"read-only-rootfs\" image feature in the image\'s recipe file via the `IMAGE_FEATURES`{.interpreted-text role="term"} variable:

> 要创建只读的根文件系统，只需通过以下两种方式之一将“read-only-rootfs”功能添加到您的镜像中即可。第一种方式是通过 `IMAGE_FEATURES`{.interpreted-text role="term"}变量在镜像的配方文件中添加“read-only-rootfs”镜像功能：

```
IMAGE_FEATURES += "read-only-rootfs"
```

As an alternative, you can add the same feature from within your `Build Directory`{.interpreted-text role="term"}\'s `local.conf` file with the associated `EXTRA_IMAGE_FEATURES`{.interpreted-text role="term"} variable, as in:

> 作为替代，您可以在“构建目录”的“local.conf”文件中使用相关的“EXTRA_IMAGE_FEATURES”变量添加相同的功能，如：

```
EXTRA_IMAGE_FEATURES = "read-only-rootfs"
```

For more information on how to use these variables, see the \"``dev-manual/customizing-images:Customizing Images Using Custom \`\`IMAGE_FEATURES\`\` and \`\`EXTRA_IMAGE_FEATURES\`\` ``{.interpreted-text role="ref"}\" section. For information on the variables, see `IMAGE_FEATURES`{.interpreted-text role="term"} and `EXTRA_IMAGE_FEATURES`{.interpreted-text role="term"}.

> 要了解如何使用这些变量的更多信息，请参见“dev-manual/customizing-images：使用自定义 IMAGE_FEATURES 和 EXTRA_IMAGE_FEATURES 自定义图像”部分。有关变量的信息，请参见 IMAGE_FEATURES 和 EXTRA_IMAGE_FEATURES。

# Post-Installation Scripts and Read-Only Root Filesystem

It is very important that you make sure all post-Installation (`pkg_postinst`) scripts for packages that are installed into the image can be run at the time when the root filesystem is created during the build on the host system. These scripts cannot attempt to run during the first boot on the target device. With the \"read-only-rootfs\" feature enabled, the build system makes sure that all post-installation scripts succeed at file system creation time. If any of these scripts still need to be run after the root filesystem is created, the build immediately fails. These build-time checks ensure that the build fails rather than the target device fails later during its initial boot operation.

> 非常重要的是，您必须确保安装到映像中的所有后安装（`pkg_postinst`）脚本在主机系统上构建时创建根文件系统时可以运行。这些脚本不能尝试在目标设备的第一次启动时运行。启用“只读根文件系统”功能后，构建系统确保所有后安装脚本在文件系统创建时成功。如果这些脚本仍然需要在创建根文件系统后运行，构建立即失败。这些构建时检查确保构建失败，而不是目标设备稍后在其初始启动操作期间失败。

Most of the common post-installation scripts generated by the build system for the out-of-the-box Yocto Project are engineered so that they can run during root filesystem creation (e.g. post-installation scripts for caching fonts). However, if you create and add custom scripts, you need to be sure they can be run during this file system creation.

> 大多数由构建系统为开箱即用的 Yocto 项目生成的常见后安装脚本都是这样设计的，它们可以在根文件系统创建期间运行（例如缓存字体的后安装脚本）。但是，如果您创建并添加自定义脚本，则需要确保它们可以在此文件系统创建期间运行。

Here are some common problems that prevent post-installation scripts from running during root filesystem creation:

- *Not using \$D in front of absolute paths:* The build system defines `$``D`{.interpreted-text role="term"} when the root filesystem is created. Furthermore, `$D` is blank when the script is run on the target device. This implies two purposes for `$D`: ensuring paths are valid in both the host and target environments, and checking to determine which environment is being used as a method for taking appropriate actions.

> 不在绝对路径前使用$D：在创建根文件系统时，构建系统定义了$D。此外，当脚本在目标设备上运行时，$D为空。这意味着$D 有两个用途：确保路径在主机和目标环境中都有效，并检查以确定正在使用哪个环境以采取适当的操作。

- *Attempting to run processes that are specific to or dependent on the target architecture:* You can work around these attempts by using native tools, which run on the host system, to accomplish the same tasks, or by alternatively running the processes under QEMU, which has the `qemu_run_binary` function. For more information, see the `ref-classes-qemu`{.interpreted-text role="ref"} class.

> 尝试运行特定于或依赖于目标架构的进程：您可以通过使用运行在主机系统上的本机工具来实现相同的任务，或者通过 QEMU 来运行这些进程，QEMU 具有 `qemu_run_binary` 函数。有关更多信息，请参阅 `ref-classes-qemu`{.interpreted-text role="ref"}类。

# Areas With Write Access

With the \"read-only-rootfs\" feature enabled, any attempt by the target to write to the root filesystem at runtime fails. Consequently, you must make sure that you configure processes and applications that attempt these types of writes do so to directories with write access (e.g. `/tmp` or `/var/run`).

> 当启用“只读根文件系统”功能时，目标尝试在运行时写入根文件系统的任何尝试都会失败。因此，您必须确保配置尝试这些类型写入的进程和应用程序，以便将其写入具有写入访问权限的目录（例如 `/tmp` 或 `/var/run`）。
