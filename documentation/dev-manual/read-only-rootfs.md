---
tip: translate by baidu@2023-06-07 17:15:55
...
---
title: Creating a Read-Only Root Filesystem
-------------------------------------------

Suppose, for security reasons, you need to disable your target device\'s root filesystem\'s write permissions (i.e. you need a read-only root filesystem). Or, perhaps you are running the device\'s operating system from a read-only storage device. For either case, you can customize your image for that behavior.

> 假设，出于安全原因，您需要禁用目标设备的根文件系统的写入权限（即，您需要一个只读的根文件）。或者，您可能正在只读存储设备上运行设备的操作系统。对于任何一种情况，您都可以针对该行为自定义图像。

::: note
::: title
Note
:::

Supporting a read-only root filesystem requires that the system and applications do not try to write to the root filesystem. You must configure all parts of the target system to write elsewhere, or to gracefully fail in the event of attempting to write to the root filesystem.

> 支持只读根文件系统要求系统和应用程序不尝试写入根文件系统。您必须将目标系统的所有部分配置为在其他地方写入，或者在尝试写入根文件系统时正常失败。
> :::

# Creating the Root Filesystem

To create the read-only root filesystem, simply add the \"read-only-rootfs\" feature to your image, normally in one of two ways. The first way is to add the \"read-only-rootfs\" image feature in the image\'s recipe file via the `IMAGE_FEATURES`{.interpreted-text role="term"} variable:

> 要创建只读根文件系统，只需在映像中添加“只读 rootfs”功能，通常采用以下两种方式之一。第一种方法是通过 `image_FATURE`｛.explored text role=“term”｝变量在图像的配方文件中添加“只读 rootfs”图像功能：

```
IMAGE_FEATURES += "read-only-rootfs"
```

As an alternative, you can add the same feature from within your `Build Directory`{.interpreted-text role="term"}\'s `local.conf` file with the associated `EXTRA_IMAGE_FEATURES`{.interpreted-text role="term"} variable, as in:

> 另一种选择是，您可以在“构建目录”的“local.conf”文件中添加相同的功能，以及相关的“EXTRA_IMAGE_feature`”变量，如：

```
EXTRA_IMAGE_FEATURES = "read-only-rootfs"
```

For more information on how to use these variables, see the \"``dev-manual/customizing-images:Customizing Images Using Custom \`\`IMAGE_FEATURES\`\` and \`\`EXTRA_IMAGE_FEATURES\`\` ``{.interpreted-text role="ref"}\" section. For information on the variables, see `IMAGE_FEATURES`{.interpreted-text role="term"} and `EXTRA_IMAGE_FEATURES`{.interpreted-text role="term"}.

> 有关如何使用这些变量的更多信息，请参阅\“`dev manual/customizing images:customizing images Using Custom\`\`IMAGE_FATURE\`\` and `\``EXTRA_IMAGE_FEATURE\ `\``{.depreted text role=“ref”}\”一节。有关变量的信息，请参阅` IMAGE_FATURE `｛.explored text role=“term”｝和` EXTRA_IMAGE_FEATURE`{.explered text rol=“term“｝。

# Post-Installation Scripts and Read-Only Root Filesystem

It is very important that you make sure all post-Installation (`pkg_postinst`) scripts for packages that are installed into the image can be run at the time when the root filesystem is created during the build on the host system. These scripts cannot attempt to run during the first boot on the target device. With the \"read-only-rootfs\" feature enabled, the build system makes sure that all post-installation scripts succeed at file system creation time. If any of these scripts still need to be run after the root filesystem is created, the build immediately fails. These build-time checks ensure that the build fails rather than the target device fails later during its initial boot operation.

> 确保在主机系统上构建根文件系统时，可以运行映像中安装的包的所有安装后（“pkg_postinst”）脚本，这一点非常重要。在目标设备上的第一次启动期间，这些脚本无法尝试运行。启用“只读 rootfs”功能后，构建系统会确保所有安装后脚本在文件系统创建时都能成功。如果在创建根文件系统之后仍然需要运行这些脚本中的任何一个，则构建会立即失败。这些构建时间检查确保构建失败，而不是目标设备稍后在其初始引导操作期间失败。

Most of the common post-installation scripts generated by the build system for the out-of-the-box Yocto Project are engineered so that they can run during root filesystem creation (e.g. post-installation scripts for caching fonts). However, if you create and add custom scripts, you need to be sure they can be run during this file system creation.

> 构建系统为开箱即用 Yocto 项目生成的大多数常见安装后脚本都经过了设计，以便它们可以在根文件系统创建期间运行（例如，用于缓存字体的安装后脚本）。但是，如果创建并添加自定义脚本，则需要确保它们可以在创建文件系统期间运行。

Here are some common problems that prevent post-installation scripts from running during root filesystem creation:

> 以下是一些常见问题，这些问题会阻止安装后脚本在根文件系统创建过程中运行：

- *Not using \$D in front of absolute paths:* The build system defines `$``D`{.interpreted-text role="term"} when the root filesystem is created. Furthermore, `$D` is blank when the script is run on the target device. This implies two purposes for `$D`: ensuring paths are valid in both the host and target environments, and checking to determine which environment is being used as a method for taking appropriate actions.

> -*在绝对路径前不使用\$D：*创建根文件系统时，构建系统定义 `$``D`｛.explored text role=“term”｝。此外，当脚本在目标设备上运行时，“$D”为空。这意味着“$D”有两个目的：确保路径在主机和目标环境中都是有效的，以及检查以确定使用哪个环境作为采取适当行动的方法。

- *Attempting to run processes that are specific to or dependent on the target architecture:* You can work around these attempts by using native tools, which run on the host system, to accomplish the same tasks, or by alternatively running the processes under QEMU, which has the `qemu_run_binary` function. For more information, see the `ref-classes-qemu`{.interpreted-text role="ref"} class.

> -*尝试运行特定于或依赖于目标体系结构的进程：*您可以通过使用在主机系统上运行的本地工具来完成相同的任务，或者通过在具有“QEMU_run_binary”功能的 QEMU 下运行进程来解决这些尝试。有关更多信息，请参阅 `ref classes qemu`｛.explored text role=“ref”｝类。

# Areas With Write Access

With the \"read-only-rootfs\" feature enabled, any attempt by the target to write to the root filesystem at runtime fails. Consequently, you must make sure that you configure processes and applications that attempt these types of writes do so to directories with write access (e.g. `/tmp` or `/var/run`).

> 启用“只读 rootfs”功能后，目标在运行时向根文件系统写入的任何尝试都会失败。因此，您必须确保配置了尝试对具有写访问权限的目录（例如“/tmp”或“/var/run”）执行这些类型写操作的进程和应用程序。
